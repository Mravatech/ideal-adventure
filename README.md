# Dockerized PHP Scripts

This project consists of a 3 PHP scripts that are designed to be executed in sequence using Docker containers. The scripts perform HTTP requests and process responses in a specific order, ensuring that each step is completed before the next one starts. The entire process is coordinated using Docker Compose.

## Prerequisites

- Docker
- Docker Compose

## Project Structure
├── Dockerfile
├── docker-compose.yml
├── script1.php
├── script2.php
├── script3.php
├── wait-for-it.sh
├── RequestService.php
├── HttpClient.php
├── HttpClientFactory.php
└── README.md


## Main Components
1. Dockerfile:
    - Defines the environment for the PHP scripts.
    - Based on the php:8.3-cli image.
    - Installs necessary dependencies like curl.

2. docker-compose.yml:
    - Orchestrates the execution of the PHP scripts.
    - Defines four services: script1, script2_0, script2_1, script2_2, and script3.
    - Uses depends_on to manage the order of execution and ensure scripts run in sequence.

3. wait-for-it.sh:
    - A shell script used to wait for the creation of specific files.
    - Ensures that each script only starts after the necessary conditions are met.

4. PHP Scripts:

    - script1.php:
      - Initiates the process by making an initial HTTP request.
      - Saves the response data to a file and signals completion by creating script1_complete.
    - script2.php (executed as script2_0, script2_1, script2_2):
      - Processes a specific URL from the initial response.
      - Generates a hash for the URL content and signals completion by creating script2_<index>_complete.
    - script3.php:
        - Waits for all instances of script2 to complete.
        - Collects the hashes generated by script2 instances.
        - Sends the final results to the server.
5. PHP Classes:

    - HttpClient:
        - Provides methods for making HTTP GET, POST, and PUT requests.
    - HttpClientFactory:
        - Factory class to create instances of HttpClient.
    - RequestService:
        - Handles the logic of making requests and processing responses.
        - Includes methods to start the process, process URLs, and send results.

## Solution Flow
- Build the Docker Image:

    - The Docker image is built using the Dockerfile, setting up the necessary PHP environment.

- Run the Containers:
    - docker-compose up starts the services defined in docker-compose.yml.
    - script1 runs first, making the initial HTTP request and saving the response data.
    - Three instances of script2 (script2_0, script2_1, script2_2) run in parallel, each processing a different URL from the response.
    - script3 runs last, waiting for all script2 instances to complete, collecting the hashes, and sending the final results.

- Synchronization:

    - The wait-for-it.sh script ensures that each script starts only after the necessary files are created, providing synchronization between the scripts.

## Setup and Running

1. **Build the Docker image**:
   ```sh
   docker-compose build
   ```
   
2. **Build the Docker image**:
   ```sh
   docker-compose up
   ```

## Example Output
![example output.](https://i.ibb.co/8b0HHWb/image.png)


## Notes
- Ensure that Docker and Docker Compose are installed and running on your system.
- The provided wait-for-it.sh script is used to ensure that each script only starts after the necessary prerequisites are met.

## Summary
This structured approach using Docker and Docker Compose ensures that the PHP scripts are executed in the correct order with proper synchronization, making the entire process efficient and reliable. The separation of concerns through individual scripts and classes makes the solution modular and maintainable.



